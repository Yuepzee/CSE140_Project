# -*- coding: utf-8 -*-
"""yuepeng-lee_ivan-vargas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IWslC5S1-NtD6oUYNqVKlmqv5yNkAJoO
"""

instruction_set = {
    "0110011": "R",
    "0000011": "I",
    "0001111": "I",
    "0010011": "I",
    "1100111": "I",
    "0100011": "S",
    "1100011": "SB",
    "1101111": "UJ" #UJ only has 1 possibility, jal, so no more mapping is needed for it
}
r_instructions = {
    ("000", "0000000"): "add",
    ("000", "0100000"): "sub",
    ("111", "0000000"): "and",
    ("110", "0000000"): "or",
    ("001", "0000000"): "sll",
    ("010", "0000000"): "slt",
    ("011", "0000000"): "sltu",
    ("101", "0000000"): "srl",
    ("101", "0100000"): "sra",
    ("100", "0000000"): "xor"
}
i_instructions = {  #the 2nd key isn't consistent between the I type commands, for some its the Opcode, for others its their funct3/im[11:5]
    ("000", "0010011"): "addi",
    ("000", "1100111"): "jalr",
    ("000", "0000011"): "lb",
    ("001", "0000000"): "slli", #funct7
    ("001", None): "lh",        #funct7
    ("010", "0000011"): "lw",
    ("010", "0010011"): "slti",
    ("011", "0010011"): "sltiu",
    ("100", "0010011"): "xori",
    ("101", "0000000"): "srli", #funct7
    ("101", "0100000"): "srai", #funct7
    ("110", "0010011"): "ori",
    ("111", "0010011"): "andi"
}

s_instructions = {
    "010": "sw",
    "001": "sh",
    "000": "sb"
}
sb_instructions = {
    "000": "beq",
    "101": "bge",
    "100": "blt",
    "001": "bne"
}

def twos_complement(input):
  if input[0] == "1":
    bits = len(input)
    decimal = int(input, 2)
    decimal -= (1 << bits)
    return str(decimal)
  return str(int(input,2))

def binary_to_decimal(input):
  return str(int(input,2))

def binary_to_hex(input):
  return hex(int(input,2))[2:].upper()

#For the implementation, the work on the R-type and I-type implementation was done by Ivan Vargas, and the work for the S, SB and U type instructions were done by Yuepeng Lee

def decode(instruction):
  information = {
    #Put in order of printing
    "Operation": None,
    "Rs1": None,
    "Rs2": None,
    "Rd": None,
    "Funct3": None,
    "Funct7": None,
    "Immediate": None
  }
  opcode = instruction[25:32]

  if opcode in instruction_set:
    #print("\n")
    print("Instruction Type:" + instruction_set[opcode])
    if instruction_set[opcode] != "UJ":
      #We need to set dictionaries so that once we've collected the Bits from the binary, we can pull from the dictionaries and retreive the string for whatever
      if instruction_set[opcode] == "SB":
        #SB has rs1, rs2 and immediate fields
        information["Operation"] = sb_instructions[instruction[17:20]]
        information["Rs1"] = "x" + binary_to_decimal(instruction[12:17])
        information["Rs2"] = "x" + binary_to_decimal(instruction[7:12])

        immedi = instruction[0:1] + instruction[24:25] + instruction[1:7] + instruction[20:24] + "0"
        information["Immediate"] = twos_complement(immedi)



      if instruction_set[opcode] == "S":
        #S have rs1, rs2 and immediate fields
        information["Operation"] = s_instructions[instruction[17:20]]
        information["Rs1"] = "x" + binary_to_decimal(instruction[12:17])
        information["Rs2"] = "x" + binary_to_decimal(instruction[7:12])

        immedi = instruction[0:7] + instruction[20:25]
        information["Immediate"] = twos_complement(immedi) + " (or 0x" + binary_to_hex(immedi) + ")"


      if instruction_set[opcode] == "R":
        #R has funct3, funct7, rs1, rs2 and rd fields
        information["Rs1"] = "x" + binary_to_decimal(instruction[12:17])
        information["Rs2"] = "x" + binary_to_decimal(instruction[7:12])
        information["Rd"] = "x" + binary_to_decimal(instruction[20:25])
        information["Funct3"] = instruction[17:20]
        information["Funct7"] = instruction[0:7]

        information["Operation"] = r_instructions[information["Funct3"], information["Funct7"]]

      if instruction_set[opcode] == "I":
        #I has rs1, rd and immediate fields, uses imm[11:5] as a funct7 in specific instructions
        information["Rs1"] = "x" + binary_to_decimal(instruction[12:17])
        information["Rd"] = "x" + binary_to_decimal(instruction[20:25])
        funct3 =  instruction[17:20]
        if funct3 == "001":
          #Case for when its slli
          if instruction[0:7] == "0000000":
            information["Operation"] = "slli"
            information["Immediate"] = twos_complement(instruction[7:12]) + " (or 0x" + binary_to_hex(instruction[7:12]) + ")"
          else:
          #Case for when its lh
            information["Operation"] = "lh"
            information["Immediate"] = twos_complement(instruction[0:12]) + " (or 0x" + binary_to_hex(instruction[0:12]) + ")"

        elif funct3 == "101":
          #Case for when its srli or srai
          fucnt7 = instruction[0:7]
          information["Operation"] = i_instructions[funct3, fucnt7]
          information["Immediate"] = twos_complement(instruction[7:12]) + " (or 0x" + binary_to_hex(instruction[7:12]) + ")"
        else:
          immedi = instruction[0:12]
          information["Immediate"] = twos_complement(immedi) + " (or 0x" + binary_to_hex(immedi) + ")"
          information["Operation"] = i_instructions[funct3, opcode]



    else:
      #For when it is a UJ type instruction
      information["Operation"] = "jal"

      rd = binary_to_decimal(instruction[20:25])
      information["Rd"] = "x" + rd

      immedi = instruction[0:1] + instruction[12:20] + instruction[11:12] + instruction[1:11] + "0"
      information["Immediate"] = twos_complement(immedi) + " (or 0x" + binary_to_hex(immedi) + ")"
  else:
    print("Invalid Opcode")

  for key in information:
    if information[key] != None:
      print(key + ": " + information[key])
  print("\n")

while(True):
  print("Enter an instruction:" + "\n")
  instruction = input()
  print("")
  if len(instruction) != 32:
    print("Invalid Input")
    break
  else:
    decode(instruction)


print("Ending Program")